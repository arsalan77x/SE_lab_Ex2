# گزارش آزمایش دوم - Test-driven developement (TDD)
در این آزمایش ابتدا دو ایراد موجود در برنامه‌ی مربوط به مدیریت کتابخانه پیدا کرده و سپس برای آن دو تست یا آزمون واحد نوشته تا هدف و خواست ما از برنامه مشخص شود، سپس آن را اصلاح کرده و دوباره تست می‌گیریم. در ادامه نیز دو بخش ناقص کد را کامل می‌کنیم بدین صورت که ابتدا خواست ما از برنامه توسط چند آزمون واحد مشخص شده و سپس کد را کامل می‌کنیم.
<br>

## مراحل انجام آزمایش
### رفع ایرادات
قبل از بررسی ایرادات، ابتدا فایل LibraryTest.java را ساخته و تابع ()setup که قبل از هر تستی باید اجرا شود را تعریف می‌کنیم. این تابع پیش‌نیاز همه‌ی تست‌ها است که در شکل زیر مشخص شده است.
<br>
<p align="center">
  <img src="https://github.com/arsalan77x/SE_lab_2/assets/63359673/857b744c-f769-4cea-9112-1d1446670304" alt="Image Description">
<br>
  <em>تصویر 1</em>
</p>
<br>

ایراد اول کد در تابع lendBook در کلاس Library است(تصویر 2). طبق کامنت بالای آن، خواست ما این است که به دانشجویی که در کتابخانه ثبت‌نشده است کتاب ندهیم، اما این مورد برآورده نشده. پس مطابق تصویر 3 یک آزمون واحد نوشته که assert و انتظار ما این است که نتیجه‌ی هر دو false شود چراکه هم عمل lend نباید صورت گیرد و هم در لیست دانشجو نباید کتاب باشد.

<br>
<p align="center">
  <img src="https://github.com/arsalan77x/SE_lab_2/assets/63359673/857b744c-f769-4cea-9112-1d1446670304" alt="Image Description">
<br>
  <em>تصویر 2</em>
<br>
  <img src="https://github.com/arsalan77x/SE_lab_2/assets/63359673/5097199b-2738-4f5a-9ebf-d782e103b14e" alt="Image Description"> <br>
<em>تصویر 3</em>
</p>
<br>

برای رفع این مشکل کد تصویر 4 را اضافه کرده و مطابق تصویر 5 می‌بینیم که تست به درستی پاس می‌شود.


<br>
<p align="center">
  <img src="https://github.com/arsalan77x/SE_lab_2/assets/63359673/80589700-cf56-474a-9986-bc640789bb07" alt="Image Description">
<br>
  <em>تصویر 4</em>
<br>
  <img src="https://github.com/arsalan77x/SE_lab_2/assets/63359673/775caa83-5fa8-4944-84f3-9fc5806e22c6" alt="Image Description"> <br>
<em>تصویر 5</em>
</p>
<br>


ایراد دوم مربوط به تابع returnBook است که بعد از اینکه دانشجو کتاب را به کتابخانه تحویل داد، با اینکه کتاب به کتابخانه اضافه می‌شود ولی از لیست کتاب‌های دانشجو کم نمی‌شود پس خواست و هدف خود از برنامه را مطابق آزمون واحد زیر تعریف می‌کنیم. (تصویر 6) سپس کد برنامه را مطابق تصویر 7 اصلاح کرده (خط 65 کد) و دوباره تست می‌گیریم که نتیجه در تصویر 8 قابل مشاهده است.

<br>
<p align="center">
  <img src="https://github.com/arsalan77x/SE_lab_2/assets/63359673/8a6799ca-0b49-4837-b9c8-d06bc6f7fefa" alt="Image Description">
<br>
  <em>تصویر 6</em>
<br>
  <img src="https://github.com/arsalan77x/SE_lab_2/assets/63359673/939e5102-38e9-4d5c-ab28-61b93e587d12" alt="Image Description"> <br>
<em>تصویر 7</em>
  <br>
    <img src="https://github.com/arsalan77x/SE_lab_2/assets/63359673/27a93752-f0c9-44b7-ba86-caea0107e5ea" alt="Image Description"> <br>
<em>تصویر 8</em>
</p>
<br>


### تکمیل کد
<br>

در این قسمت ابتدا خواست خود از تابع searchBooks با چهار آزمون واحد زیر مشخص می‌کنیم. در توابع تصویر 9 به ترتیب می‌خواهیم لیست یک تعداد کتاب را با کلید آیدی، عنوان، نویسنده و اسم بگیریم که مورد آخر نباید پذیرفته شود چون اسم برای دانشجو است. البته برنامه تابعی برای گرفتن آیدی نداشت که آن را هم اضافه کردیم.تست آخر رد نمی‌شود چون در حال حاضر که تابعی نیست هم null خروجی می‌دهد. در ادامه بعد از اینکه تست‌ها رد شد به تکمیل کد پرداخته. (تصویر 10) در انتها نیز بار دیگر تست‌ها را اجرا کرده و همگی پاس شدند. (تصویر 11)

<br>
<p align="center">
  <img src="https://github.com/arsalan77x/SE_lab_2/assets/63359673/9bbd9d81-b13b-4a51-a71e-40f1e89e4dd8" alt="Image Description">
<br>
  <em>تصویر 9</em>
<br>
  <img src="https://github.com/arsalan77x/SE_lab_2/assets/63359673/d1346c68-58ff-4231-aab1-692a6be99d1e" alt="Image Description"> <br>
<em>تصویر 10</em>
  <br>
    <img src="https://github.com/arsalan77x/SE_lab_2/assets/63359673/af2e9616-2cb5-46b2-9881-ad08e264ee61" alt="Image Description"> <br>
<em>تصویر 11</em>
</p>
<br>

تابع بعدی searchStudents است که روندی مشابه قبل دارد و اینجا صرفا کلید آیدی و نام است، پس سه آزمون واحد نوشته که دوتای اول باید موفق شوند با کلید‌های معتبر دانشجویان را پیدا کرده و سومی باید null خروجی دهد. مطابق تصویر 12 در ابتدا همگی ناموفق هستند. در تصویر 13 این تابع را کامل کردیم و در تصویر 14 تست نهایی پاس شد. در انتها نیز همگی تست‌ها را مجدد اجرا کردیم و برنامه با موفقیت اجرا شد.

<br>
<p align="center">
  <img src="https://github.com/arsalan77x/SE_lab_2/assets/63359673/0d70dbb7-c8b8-427c-bb31-9c7572a691ff" alt="Image Description">
<br>
  <em>تصویر 12</em>
<br>
  <img src="https://github.com/arsalan77x/SE_lab_2/assets/63359673/0d2f6d67-9554-474f-a133-d7b4b3921bc5" alt="Image Description"> <br>
<em>تصویر 13</em>
  <br>
    <img src="https://github.com/arsalan77x/SE_lab_2/assets/63359673/b9381592-118b-4b04-8a47-2755c3f47be0" alt="Image Description"> <br>
<em>تصویر 14</em>
</p>
<br>

## پرسش‌ها

پرسش 1:
<br>
همانطور که از لینک داده شده یاد گرفتیم، TDD به برنامه ریزی ای اشاره دارد که در آن، ابتدا تست ها (آزمون ها) را برای پروژه ی مورد نظر می نویسیم. اطمینان حاصل می کنیم که به علت عدم پیاده سازی ویژگی فعلی، تست ها پاس نمی شوند. سپس، قطعه کدی که بتواند آن تست ها را پاس کند می نویسیم و این روند را تکرار می کنیم. با توجه به ذات این کار، این طرز کار مناسب وقتی است که داریم روی پروژه ای کار می کنیم که به مداوم قرار است برای آن آپدیت بیاید چرا که با هر آپدیت می خواهیم اطمینان حاصل کنیم که تست های پیشین هم درست اجرا می شوند، صرفا اینکه تصمیم داریم یک فیچر جدیدی اضافه کنیم که یک سری تست جدید را نیز بتواند پاس کند. با توجه به ماهیت این کار، واضح است پروژه هایی مثل طراحی وبسایت ها، طراحی اپلیکیشن های بازی و ... که خیلی سریع آپدیت می شوند، هر چند که هر یک از آپدیت ها شاید تنها یکی دو قابلیت جدید اضافه کند، خیلی خوب است که با روش TDD پیاده سازی شوند.
برعکس، پروژه هایی که احتمال آپدیت آنها کم (یا صفر) هست، پروژه هایی هستند که از همان ابتدا یکسری ویژگی ها مد نظر بوده، هدف کد زدن برنامه و صرفا اطمینان از پاس شدن تست های مربوط به آن ویژگی ها است و برای این موارد، می توان از روش سنتی استفاده کرد. لذا مواردی مثل اینکه آیا کد ما پتانسیل انعطاف پذیری برای آپدیت های احتمالی آینده را دارد یا ندارد، جز موارد نگران کننده نخواهد بود. به عنوان مثال، کامپایلر یا مفسر نوشتن برای زبان های برنامه نویسی جز این دسته قرار می گیرند. به عنوان مثال، ما می دانیم که نحوه ی تفسیر شدن خود زبان پایتون هیچ تغییری نکرده است، اما خود توابع و کتابخانه ها ... در پایتون مواردی هستند که از Python 2.x رشد کرده و به Python 3.x ها رسیده اند. لذا، پروژه ی متمرکز روی پیاده سازی یکسری کتابخانه یا تابع جدید می تواند با TDD انجام شود، اما ذات پایه ی تفسیر شدن زبان تغییری نکرده است. به طور مشابه برای کامپایلر ها این مورد برقرار است. مورد دیگر، پیاده سازی پایه ی پایگاه داده ها مثل جداول، json و ... اشاره کرد که بیشتر با داده سر و کار دارند و ترجیحا برنامه نویسان ذات داده را مشخص نگه می دارند و تنها، رابط های کار کردن با آنها را در طول سال ها گسترش می دهند. مجددا می توان گفت که ارائه ی توابع جدید برای کار کردن با جداول پایگاه داده می تواند با TDD انجام شود اما ذات ذخیره سازی داده ها در جدول (سطر و ستون) یا نحوه ی پارس شدن json و ... جز پروژه هایی است که کارکردشان تغییر نمی کنند و لذا، می توانند با روش های سنتی برنامه نویسی انجام شوند.

<br>

پرسش 2:
<br>


<br>
در طی فرایند طراحی نرم افزار، هم تیم توسعه (developers) و هم تیم تضمین کیفیت (qa) تست اجرا می کنند تا عملکرد سیستم را ارزیابی کنند و از صحت عملکرد آن اطمینان حاصل کنند اما اینکه هر کدام از این دو تیم بیشتر روی کدام تست ها تمرکز می کنند با هم فرق دارد:
تیم توسعه بیشتر تمرکزش روی اجرا کردن و اطمینان صحت عملکرد unit test ها (یا همان developer test ها) است. به طور خلاصه، unit test می شود تستی که برای چک کردن عملکرد یک component کوچک، تابع واحد، کلاس واحد، ... از کل پروژه نوشته می شود. پس unit test تمرکز بیشتری روی جزئیات دارد. به عبارتی، حتی وقتی کل پروژه اجزایش کنار هم گذاشته نشده تا تکمیل شود، همین که بخش های کوچک را ابتدا چک کنیم که دارند درست کار می کنند یا خیر، unit testing گفته می شود. نکته ی قوت این است که شخصی که خودش کد یک component را نوشته، تسلط خوبی دارد و سریع می تواند تست ها را اجرا و به رفع ایراد ها بپردازد اما نکته ی ضعف این است که احتمالا این برنامه نویس دید و تمرکز خوبی از کل سیستم ندارد. همچنین، برای اینکه چک کنند که یک component با دیگری، به خوبی وصل می شود و کار می کنند، integration test ها را می نویسند و با آها کار می کنند اما بسته به مقیاس و اندازه کلی تمام ارتباطات مختلف سیستم با یکدیگر، integration test هم می تواند در سمت تیم توسعه هم در سمت تیم qa باشد.  
اما تیم تصمین کیفیت، بیشتر تمرکزشان روی اجرای integration test ها است. Integration test به معنی تست هایی برای سنجش یکپارچگی سیستم است، طبیعتا برای اطمینان از صحت عملکرد هر بخش کوچک در سیستم، بررسی یکپارچگی الزامی است. همچنین، تیم تضمین کیفیت روی system test ها تمرکز می کنند یعنی تست هایی که به طور کلی، سیستم کل را مورد سنجش قرار می دهد. طبیعتا چک کردن هر قابلیت ویژگی سیستم با اجرای system test در دل خود، می تواند جزئیات خیلی زیادی (که این جزئیات قبلا با unit test تست شده اند) داشته باشند. همچنین، تیم تضمین توسعه روی acceptance test هم تمرکز می کنند. یعنی ما می پذیریم که هر سیستمی اندکی ریسک دارد (مثل قطع شدن جریان برق در کامپیوتر و خیلی موارد دیگر) اما اینکه مطمئن شویم سیستم جوری پیاده سازی شده که با احتمال خیلی زیاد، خیلی خوب کار می کند به نحوی که قابل پذیرش (acceptance) عموم مردم خواهد بود و کاربران می توانند با آن سیستم کار کنند، acceptance testing گفته می شود که تیم تضمین کیفیت روی آن تمرکز می کند. (مثلا چک کنند کیفیت و سرعت سیستم از یه حدی بالاتر باشد و .... ) پس یعنی تیم qa از دید کلی تر به مساله پروژه نگاه می کنند. نکته ی قوت این تیم این است که عملکرد بخش های مختلف سیستم ها در کنار هم قرار می دهند تا تست خوبی از کل سیستم بگیرند اما نکته ی ضعف این است که این کار وقت گیر است مخصوصا وقتی سیستم بزرگ و پیچیده باشد و همچنین، این افراد در آن حدی که تیم توسعه درباره تک تک component ها دید خوبی دارند، تسلط کافی ندارند.
طبیعتا همان طور که متوجه شدید، همه ی این تست ها کنار هم، مکمل هم هستند و تیم توسعه و تضمین کیفیت با هم کار می کنند تا از صحت عملکرد سیستم نهایی اطمینان حاصل کنند.
